---
id: 29418f39-9823-46a5-9ba7-0e8c6e4a8952
---

# 堆

## 基础

##### 堆

- 特定条件的完全二叉树;

##### 大顶堆

- 任意节点的值大于等于子节点的值;

##### 小顶堆

- 任意节点的值小于等于子节点的值;

##### 堆顶和堆底

- 堆顶: 根节点;
- 堆底: 底层最靠右的节点;

##### 优先队列

- 堆常用于实现优先队列;
- 大顶堆即元素从大到小顺序出队的优先队列;

## 常用操作

|           | 时间复杂度 |
| --------- | ---------- |
| push()    | logN       |
| pop()     | logN       |
| peek()    | 1          |
| size()    | 1          |
| isEmpty() | 1          |

## 堆的实现(大顶堆为例)

### 数组实现

##### 节点和索引的映射

![节点和索引的映射](./images/2023-07-17-21-28-41.png)

##### 访问堆顶元素

- 堆顶;

##### 入堆

- 首先添加至堆底;
- 自底向顶依次比较;
  - 若插入值大于比较值, 交互节点值;
  - 直至无需交换或到达根节点;

##### 出堆

- 交换堆顶元素和堆底元素;
- 删除堆底元素;
- 自顶向底依次比较;
  - 若插入值小于比较值, 交互节点值;
  - 直至无需交换或到达叶子节点;

```typescript
export class Heap {
  _heapContainer: number[];
  _type: "min" | "max";
  constructor(type: "min" | "max") {
    this._heapContainer = [];
    this._type = type;
  }

  getParentIndex(index: number) {
    return Math.floor((index - 1) / 2);
  }

  getLeftChildrenIndex(index: number) {
    return 2 * index + 1;
  }

  getRightChildrenIndex(index: number) {
    return 2 * index + 2;
  }

  size() {
    return this._heapContainer.length;
  }

  isEmpty() {
    return this._heapContainer.length === 0;
  }

  peek() {
    if (this.isEmpty()) return null;
    return this._heapContainer[0];
  }

  push(value: number) {
    this._heapContainer.push(value);
    this.heapifyUp(this.size() - 1);
  }

  pop() {
    if (this.isEmpty()) return null;
    const popValue = this._heapContainer[0];
    this._heapContainer[0] = this._heapContainer[this.size() - 1];
    this._heapContainer.pop();
    this.heapifyDown(0);
    return popValue;
  }

  heapifyUp(index: number) {
    let currentIndex = index;
    let parentIndex = this.getParentIndex(currentIndex);
    while (parentIndex >= 0) {
      const current = this._heapContainer[currentIndex];
      const parent = this._heapContainer[parentIndex];
      if (this._type === "max") {
        if (current > parent) {
          this._heapContainer[currentIndex] = parent;
          this._heapContainer[parentIndex] = current;
          currentIndex = parentIndex;
          parentIndex = this.getParentIndex(currentIndex);
        } else {
          return;
        }
      } else {
        if (current < parent) {
          this._heapContainer[currentIndex] = parent;
          this._heapContainer[parentIndex] = current;
          currentIndex = parentIndex;
          parentIndex = this.getParentIndex(currentIndex);
        } else {
          return;
        }
      }
    }
  }

  heapifyDown(index: number) {
    let currentIndex = index;
    let leftChildrenIndex = this.getLeftChildrenIndex(currentIndex);
    let rightChildrenIndex = this.getRightChildrenIndex(currentIndex);
    const size = this.size();
    while (leftChildrenIndex <= size - 1) {
      if (this._type === "max") {
        const current = this._heapContainer[currentIndex];
        const leftChildren = this._heapContainer[leftChildrenIndex];
        const rightChildren = this._heapContainer[rightChildrenIndex];
        if (current < leftChildren) {
          this._heapContainer[currentIndex] = leftChildren;
          this._heapContainer[leftChildrenIndex] = current;
          currentIndex = leftChildrenIndex;
          leftChildrenIndex = this.getLeftChildrenIndex(currentIndex);
          rightChildrenIndex = this.getRightChildrenIndex(currentIndex);
        } else if (rightChildren && current < rightChildren) {
          this._heapContainer[currentIndex] = rightChildren;
          this._heapContainer[rightChildrenIndex] = current;
          currentIndex = rightChildrenIndex;
          leftChildrenIndex = this.getLeftChildrenIndex(currentIndex);
          rightChildrenIndex = this.getRightChildrenIndex(currentIndex);
        } else {
          return;
        }
      } else {
        const current = this._heapContainer[currentIndex];
        const leftChildren = this._heapContainer[leftChildrenIndex];
        const rightChildren = this._heapContainer[rightChildrenIndex];
        if (current > leftChildren) {
          this._heapContainer[currentIndex] = leftChildren;
          this._heapContainer[leftChildrenIndex] = current;
          currentIndex = leftChildrenIndex;
          leftChildrenIndex = this.getLeftChildrenIndex(currentIndex);
          rightChildrenIndex = this.getRightChildrenIndex(currentIndex);
        } else if (rightChildren && current > rightChildren) {
          this._heapContainer[currentIndex] = rightChildren;
          this._heapContainer[rightChildrenIndex] = current;
          currentIndex = rightChildrenIndex;
          leftChildrenIndex = this.getLeftChildrenIndex(currentIndex);
          rightChildrenIndex = this.getRightChildrenIndex(currentIndex);
        } else {
          return;
        }
      }
    }
  }
}
```

## 建堆

##### 入堆

- 创建一个空堆;
- 通过入堆方法依次添加;
- 时间复杂度为 O(nlogN);

##### 堆化操作

- 列表元素原封不动添加至堆;
- 从数组末端遍历数组, 依次执行从顶至底堆化操作;
- 时间复杂度为 O(n);

## top - k 问题

##### 遍历

- 遍历 k 轮;
- 时间复杂度 O(nk);

##### 排序

- 排序数组;
- 时间复杂度 O(nlogN);

##### 建堆

- 初始化一个小顶堆;
- 遍历数组;
- 数组前 k 个元素入堆;
- 从 k + 1 开始, 若元素大于堆顶;
  - 堆顶出堆;
  - 当前元素入堆;
- 遍历完毕后, 剩余元素即最大的 k 个元素;
- 时间复杂度 O(nlogk);
