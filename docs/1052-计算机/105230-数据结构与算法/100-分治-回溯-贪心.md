---
id: 7f5bb623-647d-4cec-8105-d7387602df9f
---

# 分治

## 分治算法

### 基本思路

- 分: 递归将原问题分为多个子问题, 直至达到最小子问题;
- 治: 从最小子问题, 从下而上合并, 构建原问题解;

### 分治前提

- 问题可以分解;
- 子问题独立;
- 子问题解可以合并;

### 分治和递归

- 分治根据实现方式的不同;
- 分为递归和迭代;

### 常见应用

- 大数乘法;
- 矩阵乘法;
- 汉诺塔问题;
- 二分查找;
- 归并/快速/桶排序;
- dfs;

### 基本模板

```python
def divide_and_conquer(problems_n):             # problems_n 为问题规模
    if problems_n < d:                          # 当问题规模足够小时, 直接解决该问题
        return solove()                         # 直接求解

    problems_k = divide(problems_n)             # 将问题分解为 k 个相同形式的子问题

    res = [0 for _ in range(k)]                 # res 用来保存 k 个子问题的解
    for problem_k in problems_k:
        res[i] = divide_and_conquer(problem_k)  # 递归的求解 k 个子问题

    ans = merge(res)                            # 合并 k 个子问题的解
    return ans                                  # 返回原问题的解
```

## 分治题目

### 汉诺塔问题

##### 题目

- [面试题 08.06](https://leetcode.cn/problems/hanota-lcci/description/);

##### 思路

- 假设 n 个圆盘;
- 将顶部 n - 1 个圆盘看作一个整体;
- 分治步骤;
  - C 为缓冲柱, 将 n-1 从 A 移至 B;
  - 将 A 剩余的 1 从 A 移至 C;
  - A 为缓冲柱, 将 n-1 从 B 移至 C;
- 终止条件;
  - 当 A 只剩 1 个时, 直接从 A 移至 C;
- 将 f(n) 问题转换为 2 个 f(n-1) 和 1 个 f(1);

```typescript
/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @return {void} Do not return anything, modify C in-place instead.
 */
var hanota = function (A, B, C) {
  const dfs = (n, A, B, C) => {
    if (n === 1) {
      C.push(A.pop());
      return;
    }
    dfs(n - 1, A, C, B);
    C.push(A.pop());
    dfs(n - 1, B, A, C);
  };

  dfs(A.length, A, B, C);
};
```

### 合并 k 个链表

##### 题目

- [23](https://leetcode.cn/problems/merge-k-sorted-lists/);

##### 思路

- 等同于链表的归并排序;
- 将单一链表中点的划分, 替换为链表数组的划分;

```typescript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {
  const merge = (l1, l2) => {
    const dummy = new ListNode(-1);
    let cur = dummy;
    while (l1 != null && l2 != null) {
      if (l1.val < l2.val) {
        cur.next = l1;
        l1 = l1.next;
      } else {
        cur.next = l2;
        l2 = l2.next;
      }
      cur = cur.next;
    }
    if (l1) cur.next = l1;
    if (l2) cur.next = l2;

    return dummy.next;
  };

  const mergeK = (lists, left, right) => {
    if (left >= right) return lists[left];
    const mid = Math.floor(left + (right - left) / 2);
    const l1 = mergeK(lists, left, mid);
    const l2 = mergeK(lists, mid + 1, right);
    return merge(l1, l2);
  };

  if (lists.length === 0) return null;
  return mergeK(lists, 0, lists.length - 1);
};
```

##### 复杂度

- 时间:;
- 空间:;

### 寻找两个正序数组的中位数

##### 题目

- [4](https://leetcode.cn/problems/median-of-two-sorted-arrays/);

##### 思路

- 当数组长度之和为奇数时, 中位数为数组第 Math.floor((m + n)/2) + 1 个元素;
- 反之为数组第 Math.floor((m + n)/2) 个元素和数组第 Math.floor((m + n)/2) + 1 个元素的平均数;
- 所以包含中位数的数组一侧个数恒为 Math.floor((m + n + 1)/2), 记作 k;
- 此时问题变为如何在两数组中取前 k 小的元素位置;
  - nums1 取 a 个, nums2 取 k - a 个;
  - 取较短元素设置为 nums1;
  - 设置两端指针 left, right 指向 nums1 两端;
  - 取中间位置 mid, 作为 a;
  - 比较 nums1[a] 和 nums2[k-a-1];
    - 如果 nums1[a] < nums2[k-a-1];
      - 说明最多有 a + k - a - 1 = k - 1 个元素比 nums1[a] 小;
      - 故 nums1[a-1] 不可能是第 k 个元素;
      - left = mid + 1;
    - 反之, right = mid;
- 此时, 可能存在的中位数对应 num1[left-1] 和 nums[k-left-1], 需要判断两者是否存在;

```typescript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function (nums1, nums2) {
  if (nums1.length > nums2.length) {
    return findMedianSortedArrays(nums2, nums1);
  }
  const k = Math.floor((nums1.length + nums2.length + 1) / 2);
  let left = 0;
  let right = nums1.length;
  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);
    if (nums1[mid] < nums2[k - mid - 1]) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  const n = left;
  const m = k - left;
  const v1 = Math.max(
    n <= 0 ? -Infinity : nums1[n - 1],
    m <= 0 ? -Infinity : nums2[m - 1]
  );
  if ((nums1.length + nums2.length) % 2 === 1) return v1;
  const v2 = Math.min(
    n >= nums1.length ? Infinity : nums1[n],
    m >= nums2.length ? Infinity : nums2[m]
  );
  return (v1 + v2) / 2;
};
```

##### 复杂度

- 时间: log(m+n);
- 空间: 1;

## 回溯算法

##### 基本思想

- 基于穷举和深度优先遍历解决问题;
- 从某个初始状态出发, 穷举所有可能, 直至找到解或无解;

##### 尝试和回退

- 当搜索过程中, 状态无法继续前进;
- 撤销上一步选择, 回退到之前状态, 尝试其他可能;

##### 剪枝

- 根据回溯问题的约束条件;
- 避免无意义的搜索路径;

##### 模板代码

- 定义决策树;
- 明确终止条件;
- 翻译代码;
  - 定义回溯函数;
  - 回溯函数主体;
    - 剪枝;
    - 选择元素;
    - 递归搜索;
    - 回退;
  - 明确终止条件;

```javascript
/* 回溯算法框架 */
function backtrack(state, choices, res) {
  // 判断是否为解
  if (isSolution(state)) {
    // 记录解
    recordSolution(state, res);
    // 不再继续搜索
    return;
  }
  // 遍历所有选择
  for (let choice of choices) {
    // 剪枝: 判断选择是否合法
    if (isValid(state, choice)) {
      // 尝试: 做出选择, 更新状态
      makeChoice(state, choice);
      // 递归搜索
      backtrack(state, choices, res);
      // 回退: 撤销选择, 恢复到之前的状态
      undoChoice(state, choice);
    }
  }
}
```

## 回溯算法题目

### 子集

##### 题目

- [78](https://leetcode.cn/problems/subsets/);

##### 思路

- 对于每个元素, 都有选与不选两个选择;
- 遍历数组;
  - 当前元素索引为 cur, 遍历 nums[cur+1:-1], 避免选取重复元素;
  - 添加当前路径到 res;
  - 逐个假设其被选择, 递归选择元素, 其为下一次递归的当前元素;
  - 直至到达数组末尾;

```typescript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
  const backtrack = (res, state, index, nums) => {
    res.push([...state]);
    if (index === nums.length) {
      return;
    }
    for (let i = index; i < nums.length; i++) {
      state.push(nums[i]);
      backtrack(res, state, i + 1, nums);
      state.pop();
    }
  };

  const res = [];
  backtrack(res, [], 0, nums);

  return res;
};
```

##### 复杂度

- 时间:n\*2^n;
- 空间:n;

### n 皇后

##### 题目

- [58](https://leetcode.cn/problems/n-queens/);

##### 思路

- 每一行只能放置一个皇后;
  - 遍历数组一维索引, 逐索引放置;
- 约束条件;
  - 每一列只能放置一个皇后;
    - 定义长度为 n 的布尔数组 cols, 记录每一列是否有皇后;
  - 同一对角线只能放置一个皇后;
    - 主对角线上的格子 row - col 为恒定值, 范围为 [-n+1,n-1];
    - 次对角线上的格子 row + col 为恒定值, 范围为 [0,2n-2];
    - 定义 diags 数组, 记录对角线上是否有皇后;

```typescript
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function (n) {
  const dfs = (row, n, state, res, cols, diags1, diags2) => {
    if (row >= n) {
      res.push(state.map((row) => row.join("")));
      return;
    }
    for (let col = 0; col < n; col++) {
      const diag1 = row - col + n - 1;
      const diag2 = row + col;
      if (!cols[col] && !diags1[diag1] && !diags2[diag2]) {
        state[row][col] = "Q";
        cols[col] = diags1[diag1] = diags2[diag2] = true;
        dfs(row + 1, n, state, res, cols, diags1, diags2);
        state[row][col] = ".";
        cols[col] = diags1[diag1] = diags2[diag2] = false;
      }
    }
  };

  const state = Array.from({ length: n }, () => Array(n).fill("."));
  const cols = Array(n).fill(false);
  const diags1 = Array(2 * n - 1).fill(false);
  const diags2 = Array(2 * n - 1).fill(false);
  const res = [];

  dfs(0, n, state, res, cols, diags1, diags2);
  return res;
};
```

##### 复杂度

- 空间: n!;
- 时间: n^2;

### 全排列问题

##### 题目

- [46](https://leetcode.cn/problems/permutations/);

##### 思路

- 引入布尔数组 selected, selected[i] 记录 nums[i] 是否被选择;
- 作出选择后, 将对应 selected[i] 赋值为 True;
- 遍历选择时, 跳过所有为 True 的 selected, 即剪枝;

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
  const backtrack = (res, state, selected, nums) => {
    if (state.length === nums.length) {
      res.push([...state]);
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (selected[i]) continue;
      selected[i] = true;
      state.push(nums[i]);
      backtrack(res, state, selected, nums);
      selected[i] = false;
      state.pop();
    }
  };

  const res = [];
  const selected = new Array(nums.length).fill(false);
  backtrack(res, [], selected, nums);

  return res;
};
```

##### 复杂度

- 时间: n\*n!;
- 空间: n;

### 组合总和

##### 题目

- [39](https://leetcode.cn/problems/combination-sum/);

##### 思路

- 通过 target-=nums[i], 少定义 sum, 也可是不使用, 看你心情;
- 首先对 nums 进行排序, 当 target < 0 或 target > sum 直接结束循环
- 明确所有选择: 对剩余元素进行遍历;
- 明确终止条件: target === 0/sum 或到达数组末端;
- 定义回溯函数: backtrack(res, state, index, target, nums);
  - 遍历 [index,-1], 避免重复组合的生成以及同一元素的重复选取;
  - target < 0 为剪枝条件;
- 终止条件;
  - 终止条件: state.length === nums.length;
  - 更新结果: target === 0/sum;

```typescript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
  const backtrack = (res, state, index, sum, target, nums) => {
    if (sum > target || index >= nums.length) return;
    if (sum === target) {
      res.push([...state]);
      return;
    }

    for (let i = index; i < nums.length; i++) {
      sum += nums[i];
      if (sum > target) break;
      state.push(nums[i]);
      backtrack(res, state, i, sum, target, nums);
      state.pop();
      sum -= nums[i];
    }
  };

  const res = [];
  candidates.sort((a, b) => a - b);
  backtrack(res, [], 0, 0, target, candidates);

  return res;
};
```

##### 复杂度

- 时间: n \* 2^n;
- 空间: n;

### 括号生成

##### 题目

- [22](https://leetcode.cn/problems/generate-parentheses/);

##### 思路

- 一共 2 \* n 个括号;
- 明确所有选择: 添加 ( 或 );
- 明确终止条件: 添加 2 \* n 个括号;
- 定义回溯函数: backtrack(state,res,n,symbol);
  - 剪枝;
    - 使用 symbol 表示当前组合是否成对匹配;
      - 添加 (, symbol+=1;
      - 添加 ), symbol-=1;
      - 只有 symbol < n, 才可添加 (;
      - 只有 symbol > 0, 才可添加 );
- 终止条件;
  - 终止条件: state.length === 2 \* n;
  - 添加结果: 终止条件且 symbol === 0;

```typescript
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
  const backtrack = (res, state, tag, n) => {
    if (state.length === 2 * n) {
      if (tag === 0) res.push(state.join(""));
      return;
    }
    if (tag > 0) {
      state.push(")");
      backtrack(res, state, tag - 1, n);
      state.pop();
    }
    if (tag < n) {
      state.push("(");
      backtrack(res, state, tag + 1, n);
      state.pop();
    }
  };

  const res = [];
  backtrack(res, [], 0, n);
  return res;
};
```

##### 复杂度

- 时间: $\frac{2^{2 \times n}}{\sqrt{n}}$;
- 空间: n;

### 复原 ip 地址

##### 题目

- [93](https://leetcode.cn/problems/restore-ip-addresses/);

##### 思路

- 通过在字符串种添加三个点生成不同 IP 地址;
- 明确所有选择: 每个部分有剩余全部元素给出;
- 终止条件: 分割为 4 部分;
- 定义回溯函数 trackback(res,state,index,s);
  - index 为剩余元素的起始索引;
- 书写回溯函数主体;
  - 剪枝;
    - 从剩余元素选择, 即 i in [index:-1];
    - 判断 s[index:i-1] 的值;
      - \> 255: 跳过;
      - 存在前导 0, 但并非单个零: 跳过;
- 终止条件;
  - 终止条件: 路径长度大于 4;
  - 更新状态: 路径长度等于 4, 且位置处于字符串末端;

```typescript
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function (s) {
  const backtrack = (res, state, index, s) => {
    if (state.length > 4) return;
    if (state.length === 4 && index === s.length) {
      res.push(state.join("."));
      return;
    }
    for (let i = index; i < s.length; i++) {
      const sub = Number(s.slice(index, i + 1));
      if (s[index] === "0" && i !== index) continue;
      if (sub < 0 || sub > 255) continue;
      state.push(sub);
      backtrack(res, state, i + 1, s);
      state.pop();
    }
  };

  const res = [];
  backtrack(res, [], 0, s);

  return res;
};
```

##### 复杂度

- 时间: 3^4 \* |s|;
- 空间: |s|;

## 贪心算法

### 概述

- 分步解决算法;
- 解决问题的每个决策阶段, 选择当前的最优解;
- 贪心作出局部最优, 期望获得全局最优;

### 特征

- 贪心选择性质: 全局最优解可通过局部最优解得到;
- 最优子结构: 问题最优解包括子问题最优解;

### 解题思路

- 转换为贪心问题: 作出当前选择, 再解决剩余子问题;;
- 贪心选择性质: 选择当前最优解;
- 最优子结构性质: 根据局部最优解构造全局最优解;

## 贪心题目

### 买卖股票的最佳时机 2

##### 题目

- [122](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/);

##### 思路

- 贪心问题: 决定当天是否买卖股票, 然后进行下一次选择;
- 贪心选择性质;
  - 赚钱就买卖, 反之不买卖;
  - 即判断当天和前一天的差值;
- 最优子结构;
  - 利润累加;

```typescript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
  let res = 0;
  for (let i = 1; i < prices.length; i++) {
    res += Math.max(0, prices[i] - prices[i - 1]);
  }
  return res;
};
```

##### 复杂度

- 时间:n;
- 空间:1;
