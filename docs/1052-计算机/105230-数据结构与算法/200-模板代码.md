# 模板代码

## 优先队列

```typescript
class MaxHeap {
  siftDown(nums, n, i) {
    while (true) {
      let l = 2 * i + 1;
      let r = 2 * i + 2;
      let ma = i;
      if (l < n && nums[l][1] > nums[ma][1]) ma = l;
      if (r < n && nums[r][1] > nums[ma][1]) ma = r;
      if (ma === i) break;
      [nums[i], nums[ma]] = [nums[ma], nums[i]];
      i = ma;
    }
  }

  siftUp(nums, i) {
    while (i > 0) {
      const parent = Math.floor((i - 1) / 2);
      if (nums[i][1] > nums[parent][1]) {
        [nums[i], nums[parent]] = [nums[parent], nums[i]];
        i = parent;
      } else {
        break;
      }
    }
  }

  heapify(nums) {
    for (let i = Math.floor(nums.length / 2) - 1; i >= 0; i--) {
      this.siftDown(nums, nums.length, i);
    }
  }

  push(nums, val) {
    nums.push(val);
    this.siftUp(nums, nums.length - 1);
  }

  pop(nums) {
    [nums[0], nums[nums.length - 1]] = [nums[nums.length - 1], nums[0]];
    this.siftDown(nums, nums.length - 1, 0);
    return nums.pop();
  }
}
```

## 并查集

```typescript
class UnionFind {
  constructor(n) {
    this.fa = new Array(n).map((_, index) => index);
  }

  find(x) {
    while (this.fa[x] !== x) {
      this.fa[x] = this.fa[this.fa[x]];
      x = this.fa[x];
    }
    return x;
  }

  union(x, y) {
    indexX = this.fa.indexOf(x);
    indexY = this.fa.indexOf(y);
    if (indexX !== indexY) {
      this.fa[x] = indexY;
    }
  }

  isConnected(x, y) {
    return this.find(x) === this.find(y);
  }
}
```
