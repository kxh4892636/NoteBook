---
id: a9938bb3-09b1-4127-a102-59df088f347d
---

# 数组和链表

## 数组

##### 数组

- 相同类型元素;
- 线性线性数据结构;

##### 优点

- 通过内存地址 O(1) 时间复杂度直接访问;

##### 缺点

- 初始化长度不可变;
  - 超过数组范围元素丢失;
  - 内存浪费;
- 插入和删除效率低;
  - 时间复杂度为 O(n);

##### 数组遍历

```typescript
function traverse(nums) {
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    count++;
  }
}
```

##### 数组查找

```typescript
function find(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == target) return i;
  }
  return -1;
}
```

## 链表

### 基础

##### 链表

- 非线性数据结构

##### 节点

- 节点值;
- 下一节点的引用;

```typescript
export class LinkedListNode<T> {
  value: T;
  next: LinkedListNode<T> | null;
  constructor(value: T, next: LinkedListNode<T> | null = null) {
    this.value = value;
    this.next = next;
  }
}
```

##### 尾节点

- 尾节点指向 null;

### 链表变形

##### 单向链表

- 节点值 + 后一节点的指针;

##### 环形链表

- 尾节点指向第一个节点;

##### 双向链表

- 节点值 +前一节点的指针 + 后一节点的指针;

![链表变形](./images/2023-07-11-23-04-25.png)

### 链表操作(基于双向链表)

##### 插入

- 改变插入位置前后两个指针;
- 时间复杂度为 O(1);

```typescript
function insert(
  node: DoublyLinkedListNode<T>,
  position: DoublyLinkedListNode<T>
) {
  const next = position.next;
  node.next = position.next;
  position.next = node;
  node.before = position;
  if (next) next.before = node;
  this.size += 1;
  return true;
}
```

##### 删除

- 改变删除位置前一个节点的指针;
- 双向链表时间复杂度为 O(1), 其余形式为 O(n);

```typescript
function remove(node: DoublyLinkedListNode<T>): boolean {
  const beforeNode = node.before;
  if (!beforeNode) return false;
  const next = node.next;
  if (next) {
    next.before = beforeNode as DoublyLinkedListNode<T>;
  }
  beforeNode.next = node.next;
  this.size -= 1;
  return true;
}
```

##### 访问

- 时间复杂度为 O(n);

```typescript
function find(value: T): DoublyLinkedListNode<T> | null {
  if (this.isEmpty()) return null;
  let node: DoublyLinkedListNode<T> | null = this.head
    .next as DoublyLinkedListNode<T>;
  while (node) {
    if (node.value === value) return node;
    node = node.next;
  }
  return null;
}
```

## 列表

### 基础

##### 列表

- 长度可变的数组;
- 运行过程中动态扩容;

##### 组成

- 初始容量;
- 数量记录;

##### 扩容机制

- 当数组元素数量超过当前容量后;
- 容量扩充至当前 2 倍;

### 列表操作

##### 访问

- 时间复杂度为 O(1);

```typescript
function get(index: number): T {
  if (index >= this.size || index < 0) throw new Error("exceed");
  return this.array[index];
}
```

##### 扩容

##### 插入

- 时间复杂度为 O(n);

```typescript
function insert(position: number, value: T): boolean {
  if (position >= this.size || position < 0) throw new Error("exceed");
  if (this.size === this.capacity) {
    const array = new Array(2 * this.capacity);
    this.capacity *= 2;
    for (let index = 0; index < position; index++) {
      const element = this.array[index];
      array[index] = element;
    }
    array[position] = value;
    for (let index = position; index < this.array.length; index++) {
      const element = this.array[index];
      array[index + 1] = element;
    }
    this.size++;
    this.array = array;
    return true;
  }
  for (let index = this.size - 1; index >= position; index--) {
    const element = this.array[index];
    this.array[index + 1] = element;
  }
  this.array[position] = value;
  this.size++;
  return true;
}
```

##### 删除

- 时间复杂度为 O(n);

```typescript
function remove(position: number): T {
  if (position >= this.size || position < 0) throw new Error("exceed");
  const deleteElement = this.array[position];
  for (let index = position + 1; index < this.array.length; index++) {
    const element = this.array[index];
    this.array[index - 1] = element;
  }
  this.size--;
  return deleteElement;
}
```

##### 添加

- 时间复杂度为 O(1);
- 扩容时为 O(n);

```typescript
function append(value: T) {
  if (this.size === this.capacity) {
    const array = new Array(2 * this.capacity);
    this.capacity *= 2;
    for (let index = 0; index < this.array.length; index++) {
      const element = this.array[index];
      array[index] = element;
    }
    array[this.size] = value;
    this.size++;
    this.array = array;
    return true;
  }
  this.array[this.size] = value;
  this.size++;
  return true;
}
```
